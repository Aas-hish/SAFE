{"ast":null,"code":"import { SAFE_DATA } from './data';\n\n// Constants\nconst MIN_RATING = 1;\nconst MAX_RATING = 5;\nconst PERFECT_SCORE = 5;\nconst MIN_CRITICAL_PERCENTAGE = 0.1; // 10% for critical metrics\n\n/**\n * Clamps a value between min and max\n */\nconst clamp = (value, min, max) => Math.max(min, Math.min(max, value));\n\n/**\n * Normalizes weights to sum to 100\n */\nconst normalizeWeights = (weights, count) => {\n  const sum = weights.reduce((s, w) => s + w, 0);\n  return sum > 0 ? weights.map(w => w / sum * 100) : Array(count).fill(100 / count);\n};\n\n/**\n * Validates and normalizes a rating value\n */\nconst validateRating = rating => {\n  const num = Number(rating);\n  if (isNaN(num)) return 0;\n  return clamp(num, MIN_RATING, MAX_RATING);\n};\nexport function calculateCompletionFromState(appState) {\n  if (!(appState !== null && appState !== void 0 && appState.ratings)) return 0;\n  let totalMetrics = 0;\n  let ratedMetrics = 0;\n  Object.entries(SAFE_DATA).forEach(([dimName, kpis]) => {\n    Object.entries(kpis).forEach(([kpiName, metrics]) => {\n      metrics.forEach(metric => {\n        const key = `${dimName}||${kpiName}||${metric.name}`;\n        totalMetrics += 1;\n        if (appState.ratings[key] !== undefined && appState.ratings[key] !== null) {\n          ratedMetrics += 1;\n        }\n      });\n    });\n  });\n  return totalMetrics > 0 ? Math.round(ratedMetrics / totalMetrics * 100) : 0;\n}\nexport function calculateScoresFromState(appState) {\n  if (!(appState !== null && appState !== void 0 && appState.ratings) || !(appState !== null && appState !== void 0 && appState.weights)) {\n    return {\n      overall: 0,\n      dimensions: {}\n    };\n  }\n  const dimensions = {};\n  let totalWeightedScore = 0;\n  let totalWeight = 0;\n\n  // Process each dimension\n  Object.entries(SAFE_DATA).forEach(([dimName, kpis]) => {\n    let dimScoreSum = 0;\n    let dimWeightSum = 0;\n    const kpiEntries = Object.entries(kpis);\n\n    // Process each KPI in the dimension\n    kpiEntries.forEach(([kpiName, metrics]) => {\n      const kpiKey = `${dimName}||${kpiName}`;\n      const defaultKpiWeight = 100 / kpiEntries.length;\n      const kpiWeight = Math.max(0, Number(appState.weights.kpis[kpiKey]) || defaultKpiWeight);\n\n      // Calculate weighted average of metrics\n      let kpiMetricScoreSum = 0;\n      let kpiMetricWeightSum = 0;\n      const metricWeights = [];\n      metrics.forEach(metric => {\n        const metricKey = `${dimName}||${kpiName}||${metric.name}`;\n        const rating = validateRating(appState.ratings[metricKey]);\n        const defaultMetricWeight = 100 / metrics.length;\n        const metricWeight = Math.max(0, Number(appState.weights.metrics[metricKey]) || defaultMetricWeight);\n        metricWeights.push(metricWeight);\n        kpiMetricScoreSum += rating * metricWeight;\n        kpiMetricWeightSum += metricWeight;\n      });\n\n      // Normalize weights to ensure they sum to 100%\n      const normalizedWeights = normalizeWeights(metricWeights, metrics.length);\n      let kpiAverage = 0;\n      if (kpiMetricWeightSum > 0) {\n        kpiAverage = metrics.reduce((sum, metric, index) => {\n          const metricKey = `${dimName}||${kpiName}||${metric.name}`;\n          const rating = validateRating(appState.ratings[metricKey]);\n          return sum + rating * normalizedWeights[index];\n        }, 0) / 100; // Divide by 100 because weights sum to 100\n      }\n      dimScoreSum += kpiAverage * kpiWeight;\n      dimWeightSum += kpiWeight;\n    });\n\n    // Calculate dimension score\n    const dimScore = dimWeightSum > 0 ? dimScoreSum / dimWeightSum : 0;\n    dimensions[dimName] = {\n      score: Number(dimScore.toFixed(2)),\n      maxScore: PERFECT_SCORE\n    };\n\n    // Accumulate for overall score\n    totalWeightedScore += dimScore * (dimWeightSum || 1);\n    totalWeight += dimWeightSum || 1;\n  });\n\n  // Calculate overall score\n  const overall = totalWeight > 0 ? Number((totalWeightedScore / totalWeight).toFixed(2)) : 0;\n  return {\n    overall,\n    maxScore: PERFECT_SCORE,\n    dimensions\n  };\n}\nexport function countNonZeroWeightageMetrics(appState) {\n  var _appState$weights;\n  if (!(appState !== null && appState !== void 0 && (_appState$weights = appState.weights) !== null && _appState$weights !== void 0 && _appState$weights.metrics)) return 0;\n  let count = 0;\n  const seenMetrics = new Set();\n  Object.entries(SAFE_DATA).forEach(([dimName, kpis]) => {\n    Object.entries(kpis).forEach(([kpiName, metrics]) => {\n      metrics.forEach(metric => {\n        const metricKey = `${dimName}||${kpiName}||${metric.name}`;\n        if (seenMetrics.has(metricKey)) return;\n        const weight = Number(appState.weights.metrics[metricKey]) || 0;\n        if (weight > 0) {\n          count += 1;\n          seenMetrics.add(metricKey);\n        }\n      });\n    });\n  });\n  return count;\n}\nexport function getPerformanceCategory(overallScore) {\n  const score = Number(overallScore) || 0;\n  if (score >= 4.5) return {\n    name: 'Excellent',\n    class: 'badge-excellent'\n  };\n  if (score >= 3.5) return {\n    name: 'Good',\n    class: 'badge-good'\n  };\n  if (score >= 2.5) return {\n    name: 'Needs Improvement',\n    class: 'badge-warning'\n  };\n  return {\n    name: 'Critical',\n    class: 'badge-critical'\n  };\n}\nexport function getCriticalMetrics(appState) {\n  if (!(appState !== null && appState !== void 0 && appState.priorities) || !(appState !== null && appState !== void 0 && appState.ratings)) return [];\n  const aPriorityMetrics = Object.entries(appState.priorities).filter(([, priority]) => priority === 'A').map(([key]) => {\n    const rating = validateRating(appState.ratings[key]);\n    const nameParts = key.split('||');\n    return {\n      key,\n      score: rating,\n      name: nameParts.length >= 3 ? nameParts[2] : key,\n      dimension: nameParts[0] || 'Unknown'\n    };\n  }).sort((a, b) => a.score - b.score || a.name.localeCompare(b.name));\n\n  // Ensure we always get at least 1 critical metric if any exist\n  const minCritical = Math.min(Math.max(1, Math.floor(aPriorityMetrics.length * MIN_CRITICAL_PERCENTAGE)), aPriorityMetrics.length);\n  return aPriorityMetrics.slice(0, minCritical);\n}\nexport function generateInsights(scores) {\n  const insights = [];\n  if (!(scores !== null && scores !== void 0 && scores.dimensions)) return insights;\n  const dimensionsArray = Object.entries(scores.dimensions).map(([name, data]) => ({\n    name,\n    score: Number(data.score) || 0,\n    maxScore: Number(data.maxScore) || PERFECT_SCORE\n  })).filter(dim => !isNaN(dim.score));\n  if (dimensionsArray.length === 0) return insights;\n  const sorted = [...dimensionsArray].sort((a, b) => b.score - a.score);\n  const best = sorted[0];\n  const worst = sorted[sorted.length - 1];\n  const averageScore = dimensionsArray.reduce((sum, d) => sum + d.score, 0) / dimensionsArray.length;\n\n  // Add best dimension insight\n  if (best && best.score > 0) {\n    const performance = best.score / best.maxScore;\n    let description = `${best.name} is your strongest area with a score of ${best.score.toFixed(2)}/${best.maxScore}.`;\n    if (performance >= 0.9) {\n      description += \" Consider sharing these best practices with other areas.\";\n    } else if (performance >= 0.7) {\n      description += \" There's still room for improvement to reach excellence.\";\n    }\n    insights.push({\n      title: 'Strongest Dimension',\n      description,\n      icon: 'ðŸŒŸ',\n      priority: 'high'\n    });\n  }\n\n  // Add worst dimension insight\n  if (worst && worst.score < (best === null || best === void 0 ? void 0 : best.score)) {\n    const gap = (best.score - worst.score) / best.maxScore * 100;\n    let description = `${worst.name} has the lowest score at ${worst.score.toFixed(2)}/${worst.maxScore}.`;\n    if (gap > 30) {\n      description += ` There's a significant gap of ${gap.toFixed(0)}% compared to your best dimension.`;\n    }\n    insights.push({\n      title: 'Area Needing Attention',\n      description: description + \" Focused improvements here could significantly boost your overall score.\",\n      icon: 'âš ï¸',\n      priority: 'critical'\n    });\n  }\n\n  // Add overall performance insight\n  const overallPercentage = scores.overall / (scores.maxScore || PERFECT_SCORE) * 100;\n  let overallDescription = `Your overall score is ${scores.overall.toFixed(2)}/${scores.maxScore || PERFECT_SCORE} (${overallPercentage.toFixed(0)}%).`;\n  if (overallPercentage >= 80) {\n    overallDescription += \" Excellent work! You're performing at a high level across most dimensions.\";\n  } else if (overallPercentage >= 60) {\n    overallDescription += \" You're doing well, but there are opportunities for improvement in several areas.\";\n  } else {\n    overallDescription += \" There are significant opportunities for improvement across multiple dimensions.\";\n  }\n  insights.push({\n    title: 'Overall Performance',\n    description: overallDescription,\n    icon: 'ðŸ“Š',\n    priority: 'medium'\n  });\n\n  // Add statistical insight if we have enough dimensions\n  if (dimensionsArray.length >= 3) {\n    const scores = dimensionsArray.map(d => d.score);\n    const min = Math.min(...scores);\n    const max = Math.max(...scores);\n    const range = max - min;\n    if (range > 1.5) {\n      insights.push({\n        title: 'Performance Consistency',\n        description: `Your scores vary significantly across dimensions (range: ${range.toFixed(2)}). Consider balancing improvements across all areas.`,\n        icon: 'âš–ï¸',\n        priority: 'medium'\n      });\n    }\n  }\n\n  // Sort insights by priority\n  const priorityOrder = {\n    critical: 0,\n    high: 1,\n    medium: 2,\n    low: 3\n  };\n  return insights.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n}","map":{"version":3,"names":["SAFE_DATA","MIN_RATING","MAX_RATING","PERFECT_SCORE","MIN_CRITICAL_PERCENTAGE","clamp","value","min","max","Math","normalizeWeights","weights","count","sum","reduce","s","w","map","Array","fill","validateRating","rating","num","Number","isNaN","calculateCompletionFromState","appState","ratings","totalMetrics","ratedMetrics","Object","entries","forEach","dimName","kpis","kpiName","metrics","metric","key","name","undefined","round","calculateScoresFromState","overall","dimensions","totalWeightedScore","totalWeight","dimScoreSum","dimWeightSum","kpiEntries","kpiKey","defaultKpiWeight","length","kpiWeight","kpiMetricScoreSum","kpiMetricWeightSum","metricWeights","metricKey","defaultMetricWeight","metricWeight","push","normalizedWeights","kpiAverage","index","dimScore","score","toFixed","maxScore","countNonZeroWeightageMetrics","_appState$weights","seenMetrics","Set","has","weight","add","getPerformanceCategory","overallScore","class","getCriticalMetrics","priorities","aPriorityMetrics","filter","priority","nameParts","split","dimension","sort","a","b","localeCompare","minCritical","floor","slice","generateInsights","scores","insights","dimensionsArray","data","dim","sorted","best","worst","averageScore","d","performance","description","title","icon","gap","overallPercentage","overallDescription","range","priorityOrder","critical","high","medium","low"],"sources":["/home/aashish/Desktop/SAFE/src/scoring.js"],"sourcesContent":["import { SAFE_DATA } from './data';\n\n// Constants\nconst MIN_RATING = 1;\nconst MAX_RATING = 5;\nconst PERFECT_SCORE = 5;\nconst MIN_CRITICAL_PERCENTAGE = 0.1; // 10% for critical metrics\n\n/**\n * Clamps a value between min and max\n */\nconst clamp = (value, min, max) => Math.max(min, Math.min(max, value));\n\n/**\n * Normalizes weights to sum to 100\n */\nconst normalizeWeights = (weights, count) => {\n  const sum = weights.reduce((s, w) => s + w, 0);\n  return sum > 0 ? weights.map(w => (w / sum) * 100) : \n                  Array(count).fill(100 / count);\n};\n\n/**\n * Validates and normalizes a rating value\n */\nconst validateRating = (rating) => {\n  const num = Number(rating);\n  if (isNaN(num)) return 0;\n  return clamp(num, MIN_RATING, MAX_RATING);\n};\n\nexport function calculateCompletionFromState(appState) {\n  if (!appState?.ratings) return 0;\n  \n  let totalMetrics = 0;\n  let ratedMetrics = 0;\n\n  Object.entries(SAFE_DATA).forEach(([dimName, kpis]) => {\n    Object.entries(kpis).forEach(([kpiName, metrics]) => {\n      metrics.forEach((metric) => {\n        const key = `${dimName}||${kpiName}||${metric.name}`;\n        totalMetrics += 1;\n        if (appState.ratings[key] !== undefined && appState.ratings[key] !== null) {\n          ratedMetrics += 1;\n        }\n      });\n    });\n  });\n\n  return totalMetrics > 0 ? Math.round((ratedMetrics / totalMetrics) * 100) : 0;\n}\n\nexport function calculateScoresFromState(appState) {\n  if (!appState?.ratings || !appState?.weights) {\n    return { overall: 0, dimensions: {} };\n  }\n\n  const dimensions = {};\n  let totalWeightedScore = 0;\n  let totalWeight = 0;\n\n  // Process each dimension\n  Object.entries(SAFE_DATA).forEach(([dimName, kpis]) => {\n    let dimScoreSum = 0;\n    let dimWeightSum = 0;\n    const kpiEntries = Object.entries(kpis);\n\n    // Process each KPI in the dimension\n    kpiEntries.forEach(([kpiName, metrics]) => {\n      const kpiKey = `${dimName}||${kpiName}`;\n      const defaultKpiWeight = 100 / kpiEntries.length;\n      const kpiWeight = Math.max(0, Number(appState.weights.kpis[kpiKey]) || defaultKpiWeight);\n\n      // Calculate weighted average of metrics\n      let kpiMetricScoreSum = 0;\n      let kpiMetricWeightSum = 0;\n      const metricWeights = [];\n\n      metrics.forEach((metric) => {\n        const metricKey = `${dimName}||${kpiName}||${metric.name}`;\n        const rating = validateRating(appState.ratings[metricKey]);\n        const defaultMetricWeight = 100 / metrics.length;\n        const metricWeight = Math.max(0, Number(appState.weights.metrics[metricKey]) || defaultMetricWeight);\n        \n        metricWeights.push(metricWeight);\n        kpiMetricScoreSum += rating * metricWeight;\n        kpiMetricWeightSum += metricWeight;\n      });\n\n      // Normalize weights to ensure they sum to 100%\n      const normalizedWeights = normalizeWeights(metricWeights, metrics.length);\n      let kpiAverage = 0;\n      \n      if (kpiMetricWeightSum > 0) {\n        kpiAverage = metrics.reduce((sum, metric, index) => {\n          const metricKey = `${dimName}||${kpiName}||${metric.name}`;\n          const rating = validateRating(appState.ratings[metricKey]);\n          return sum + (rating * normalizedWeights[index]);\n        }, 0) / 100; // Divide by 100 because weights sum to 100\n      }\n\n      dimScoreSum += kpiAverage * kpiWeight;\n      dimWeightSum += kpiWeight;\n    });\n\n    // Calculate dimension score\n    const dimScore = dimWeightSum > 0 ? (dimScoreSum / dimWeightSum) : 0;\n    dimensions[dimName] = { \n      score: Number(dimScore.toFixed(2)),\n      maxScore: PERFECT_SCORE\n    };\n\n    // Accumulate for overall score\n    totalWeightedScore += dimScore * (dimWeightSum || 1);\n    totalWeight += dimWeightSum || 1;\n  });\n\n  // Calculate overall score\n  const overall = totalWeight > 0 ? Number((totalWeightedScore / totalWeight).toFixed(2)) : 0;\n\n  return { \n    overall,\n    maxScore: PERFECT_SCORE,\n    dimensions \n  };\n}\n\nexport function countNonZeroWeightageMetrics(appState) {\n  if (!appState?.weights?.metrics) return 0;\n  \n  let count = 0;\n  const seenMetrics = new Set();\n\n  Object.entries(SAFE_DATA).forEach(([dimName, kpis]) => {\n    Object.entries(kpis).forEach(([kpiName, metrics]) => {\n      metrics.forEach((metric) => {\n        const metricKey = `${dimName}||${kpiName}||${metric.name}`;\n        if (seenMetrics.has(metricKey)) return;\n        \n        const weight = Number(appState.weights.metrics[metricKey]) || 0;\n        if (weight > 0) {\n          count += 1;\n          seenMetrics.add(metricKey);\n        }\n      });\n    });\n  });\n  \n  return count;\n}\n\nexport function getPerformanceCategory(overallScore) {\n  const score = Number(overallScore) || 0;\n  \n  if (score >= 4.5) return { name: 'Excellent', class: 'badge-excellent' };\n  if (score >= 3.5) return { name: 'Good', class: 'badge-good' };\n  if (score >= 2.5) return { name: 'Needs Improvement', class: 'badge-warning' };\n  return { name: 'Critical', class: 'badge-critical' };\n}\n\nexport function getCriticalMetrics(appState) {\n  if (!appState?.priorities || !appState?.ratings) return [];\n  \n  const aPriorityMetrics = Object.entries(appState.priorities)\n    .filter(([, priority]) => priority === 'A')\n    .map(([key]) => {\n      const rating = validateRating(appState.ratings[key]);\n      const nameParts = key.split('||');\n      return {\n        key,\n        score: rating,\n        name: nameParts.length >= 3 ? nameParts[2] : key,\n        dimension: nameParts[0] || 'Unknown'\n      };\n    })\n    .sort((a, b) => a.score - b.score || a.name.localeCompare(b.name));\n\n  // Ensure we always get at least 1 critical metric if any exist\n  const minCritical = Math.min(\n    Math.max(1, Math.floor(aPriorityMetrics.length * MIN_CRITICAL_PERCENTAGE)),\n    aPriorityMetrics.length\n  );\n  \n  return aPriorityMetrics.slice(0, minCritical);\n}\n\nexport function generateInsights(scores) {\n  const insights = [];\n  if (!scores?.dimensions) return insights;\n  \n  const dimensionsArray = Object.entries(scores.dimensions)\n    .map(([name, data]) => ({ \n      name, \n      score: Number(data.score) || 0,\n      maxScore: Number(data.maxScore) || PERFECT_SCORE\n    }))\n    .filter(dim => !isNaN(dim.score));\n\n  if (dimensionsArray.length === 0) return insights;\n\n  const sorted = [...dimensionsArray].sort((a, b) => b.score - a.score);\n  const best = sorted[0];\n  const worst = sorted[sorted.length - 1];\n  const averageScore = dimensionsArray.reduce((sum, d) => sum + d.score, 0) / dimensionsArray.length;\n\n  // Add best dimension insight\n  if (best && best.score > 0) {\n    const performance = best.score / best.maxScore;\n    let description = `${best.name} is your strongest area with a score of ${best.score.toFixed(2)}/${best.maxScore}.`;\n    \n    if (performance >= 0.9) {\n      description += \" Consider sharing these best practices with other areas.\";\n    } else if (performance >= 0.7) {\n      description += \" There's still room for improvement to reach excellence.\";\n    }\n    \n    insights.push({\n      title: 'Strongest Dimension',\n      description,\n      icon: 'ðŸŒŸ',\n      priority: 'high'\n    });\n  }\n\n  // Add worst dimension insight\n  if (worst && worst.score < best?.score) {\n    const gap = ((best.score - worst.score) / best.maxScore) * 100;\n    let description = `${worst.name} has the lowest score at ${worst.score.toFixed(2)}/${worst.maxScore}.`;\n    \n    if (gap > 30) {\n      description += ` There's a significant gap of ${gap.toFixed(0)}% compared to your best dimension.`;\n    }\n    \n    insights.push({\n      title: 'Area Needing Attention',\n      description: description + \" Focused improvements here could significantly boost your overall score.\",\n      icon: 'âš ï¸',\n      priority: 'critical'\n    });\n  }\n\n  // Add overall performance insight\n  const overallPercentage = (scores.overall / (scores.maxScore || PERFECT_SCORE)) * 100;\n  let overallDescription = `Your overall score is ${scores.overall.toFixed(2)}/${scores.maxScore || PERFECT_SCORE} (${overallPercentage.toFixed(0)}%).`;\n  \n  if (overallPercentage >= 80) {\n    overallDescription += \" Excellent work! You're performing at a high level across most dimensions.\";\n  } else if (overallPercentage >= 60) {\n    overallDescription += \" You're doing well, but there are opportunities for improvement in several areas.\";\n  } else {\n    overallDescription += \" There are significant opportunities for improvement across multiple dimensions.\";\n  }\n\n  insights.push({\n    title: 'Overall Performance',\n    description: overallDescription,\n    icon: 'ðŸ“Š',\n    priority: 'medium'\n  });\n\n  // Add statistical insight if we have enough dimensions\n  if (dimensionsArray.length >= 3) {\n    const scores = dimensionsArray.map(d => d.score);\n    const min = Math.min(...scores);\n    const max = Math.max(...scores);\n    const range = max - min;\n    \n    if (range > 1.5) {\n      insights.push({\n        title: 'Performance Consistency',\n        description: `Your scores vary significantly across dimensions (range: ${range.toFixed(2)}). Consider balancing improvements across all areas.`,\n        icon: 'âš–ï¸',\n        priority: 'medium'\n      });\n    }\n  }\n\n  // Sort insights by priority\n  const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n  return insights.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n}\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}